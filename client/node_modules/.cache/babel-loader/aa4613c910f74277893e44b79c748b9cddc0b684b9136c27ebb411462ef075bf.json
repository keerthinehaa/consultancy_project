{"ast":null,"code":"import { ReadableStream } from \"../_shims/index.mjs\";\nimport { GroqError } from \"../error.mjs\";\nimport { APIError } from \"../error.mjs\";\nexport class Stream {\n  constructor(iterator, controller) {\n    this.iterator = iterator;\n    this.controller = controller;\n  }\n  static fromSSEResponse(response, controller) {\n    let consumed = false;\n    const decoder = new SSEDecoder();\n    async function* iterMessages() {\n      if (!response.body) {\n        controller.abort();\n        throw new GroqError(`Attempted to iterate over a response with no body`);\n      }\n      const lineDecoder = new LineDecoder();\n      const iter = readableStreamAsyncIterable(response.body);\n      for await (const chunk of iter) {\n        for (const line of lineDecoder.decode(chunk)) {\n          const sse = decoder.decode(line);\n          if (sse) yield sse;\n        }\n      }\n      for (const line of lineDecoder.flush()) {\n        const sse = decoder.decode(line);\n        if (sse) yield sse;\n      }\n    }\n    async function* iterator() {\n      if (consumed) {\n        throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\n      }\n      consumed = true;\n      let done = false;\n      try {\n        for await (const sse of iterMessages()) {\n          if (done) continue;\n          if (sse.data.startsWith('[DONE]')) {\n            done = true;\n            continue;\n          }\n          if (sse.event === null || sse.event === 'error') {\n            let data;\n            try {\n              data = JSON.parse(sse.data);\n            } catch (e) {\n              console.error(`Could not parse message into JSON:`, sse.data);\n              console.error(`From chunk:`, sse.raw);\n              throw e;\n            }\n            if (data && data.error) {\n              throw new APIError(data.error.status_code, data.error, data.error.message, undefined);\n            }\n            yield data;\n          }\n        }\n        done = true;\n      } catch (e) {\n        // If the user calls `stream.controller.abort()`, we should exit without throwing.\n        if (e instanceof Error && e.name === 'AbortError') return;\n        throw e;\n      } finally {\n        // If the user `break`s, abort the ongoing request.\n        if (!done) controller.abort();\n      }\n    }\n    return new Stream(iterator, controller);\n  }\n  /**\r\n   * Generates a Stream from a newline-separated ReadableStream\r\n   * where each item is a JSON value.\r\n   */\n  static fromReadableStream(readableStream, controller) {\n    let consumed = false;\n    async function* iterLines() {\n      const lineDecoder = new LineDecoder();\n      const iter = readableStreamAsyncIterable(readableStream);\n      for await (const chunk of iter) {\n        for (const line of lineDecoder.decode(chunk)) {\n          yield line;\n        }\n      }\n      for (const line of lineDecoder.flush()) {\n        yield line;\n      }\n    }\n    async function* iterator() {\n      if (consumed) {\n        throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\n      }\n      consumed = true;\n      let done = false;\n      try {\n        for await (const line of iterLines()) {\n          if (done) continue;\n          if (line) yield JSON.parse(line);\n        }\n        done = true;\n      } catch (e) {\n        // If the user calls `stream.controller.abort()`, we should exit without throwing.\n        if (e instanceof Error && e.name === 'AbortError') return;\n        throw e;\n      } finally {\n        // If the user `break`s, abort the ongoing request.\n        if (!done) controller.abort();\n      }\n    }\n    return new Stream(iterator, controller);\n  }\n  [Symbol.asyncIterator]() {\n    return this.iterator();\n  }\n  /**\r\n   * Splits the stream into two streams which can be\r\n   * independently read from at different speeds.\r\n   */\n  tee() {\n    const left = [];\n    const right = [];\n    const iterator = this.iterator();\n    const teeIterator = queue => {\n      return {\n        next: () => {\n          if (queue.length === 0) {\n            const result = iterator.next();\n            left.push(result);\n            right.push(result);\n          }\n          return queue.shift();\n        }\n      };\n    };\n    return [new Stream(() => teeIterator(left), this.controller), new Stream(() => teeIterator(right), this.controller)];\n  }\n  /**\r\n   * Converts this stream to a newline-separated ReadableStream of\r\n   * JSON stringified values in the stream\r\n   * which can be turned back into a Stream with `Stream.fromReadableStream()`.\r\n   */\n  toReadableStream() {\n    const self = this;\n    let iter;\n    const encoder = new TextEncoder();\n    return new ReadableStream({\n      async start() {\n        iter = self[Symbol.asyncIterator]();\n      },\n      async pull(ctrl) {\n        try {\n          const {\n            value,\n            done\n          } = await iter.next();\n          if (done) return ctrl.close();\n          const bytes = encoder.encode(JSON.stringify(value) + '\\n');\n          ctrl.enqueue(bytes);\n        } catch (err) {\n          ctrl.error(err);\n        }\n      },\n      async cancel() {\n        await iter.return?.();\n      }\n    });\n  }\n}\nclass SSEDecoder {\n  constructor() {\n    this.event = null;\n    this.data = [];\n    this.chunks = [];\n  }\n  decode(line) {\n    if (line.endsWith('\\r')) {\n      line = line.substring(0, line.length - 1);\n    }\n    if (!line) {\n      // empty line and we didn't previously encounter any messages\n      if (!this.event && !this.data.length) return null;\n      const sse = {\n        event: this.event,\n        data: this.data.join('\\n'),\n        raw: this.chunks\n      };\n      this.event = null;\n      this.data = [];\n      this.chunks = [];\n      return sse;\n    }\n    this.chunks.push(line);\n    if (line.startsWith(':')) {\n      return null;\n    }\n    let [fieldname, _, value] = partition(line, ':');\n    if (value.startsWith(' ')) {\n      value = value.substring(1);\n    }\n    if (fieldname === 'event') {\n      this.event = value;\n    } else if (fieldname === 'data') {\n      this.data.push(value);\n    }\n    return null;\n  }\n}\n/**\r\n * A re-implementation of httpx's `LineDecoder` in Python that handles incrementally\r\n * reading lines from text.\r\n *\r\n * https://github.com/encode/httpx/blob/920333ea98118e9cf617f246905d7b202510941c/httpx/_decoders.py#L258\r\n */\nclass LineDecoder {\n  constructor() {\n    this.buffer = [];\n    this.trailingCR = false;\n  }\n  decode(chunk) {\n    let text = this.decodeText(chunk);\n    if (this.trailingCR) {\n      text = '\\r' + text;\n      this.trailingCR = false;\n    }\n    if (text.endsWith('\\r')) {\n      this.trailingCR = true;\n      text = text.slice(0, -1);\n    }\n    if (!text) {\n      return [];\n    }\n    const trailingNewline = LineDecoder.NEWLINE_CHARS.has(text[text.length - 1] || '');\n    let lines = text.split(LineDecoder.NEWLINE_REGEXP);\n    if (lines.length === 1 && !trailingNewline) {\n      this.buffer.push(lines[0]);\n      return [];\n    }\n    if (this.buffer.length > 0) {\n      lines = [this.buffer.join('') + lines[0], ...lines.slice(1)];\n      this.buffer = [];\n    }\n    if (!trailingNewline) {\n      this.buffer = [lines.pop() || ''];\n    }\n    return lines;\n  }\n  decodeText(bytes) {\n    if (bytes == null) return '';\n    if (typeof bytes === 'string') return bytes;\n    // Node:\n    if (typeof Buffer !== 'undefined') {\n      if (bytes instanceof Buffer) {\n        return bytes.toString();\n      }\n      if (bytes instanceof Uint8Array) {\n        return Buffer.from(bytes).toString();\n      }\n      throw new GroqError(`Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global \"Buffer\" defined, which this library assumes to be Node. Please report this error.`);\n    }\n    // Browser\n    if (typeof TextDecoder !== 'undefined') {\n      if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {\n        this.textDecoder ?? (this.textDecoder = new TextDecoder('utf8'));\n        return this.textDecoder.decode(bytes);\n      }\n      throw new GroqError(`Unexpected: received non-Uint8Array/ArrayBuffer (${bytes.constructor.name}) in a web platform. Please report this error.`);\n    }\n    throw new GroqError(`Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`);\n  }\n  flush() {\n    if (!this.buffer.length && !this.trailingCR) {\n      return [];\n    }\n    const lines = [this.buffer.join('')];\n    this.buffer = [];\n    this.trailingCR = false;\n    return lines;\n  }\n}\n// prettier-ignore\nLineDecoder.NEWLINE_CHARS = new Set(['\\n', '\\r', '\\x0b', '\\x0c', '\\x1c', '\\x1d', '\\x1e', '\\x85', '\\u2028', '\\u2029']);\nLineDecoder.NEWLINE_REGEXP = /\\r\\n|[\\n\\r\\x0b\\x0c\\x1c\\x1d\\x1e\\x85\\u2028\\u2029]/g;\nfunction partition(str, delimiter) {\n  const index = str.indexOf(delimiter);\n  if (index !== -1) {\n    return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];\n  }\n  return [str, '', ''];\n}\n/**\r\n * Most browsers don't yet have async iterable support for ReadableStream,\r\n * and Node has a very different way of reading bytes from its \"ReadableStream\".\r\n *\r\n * This polyfill was pulled from https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\r\n */\nexport function readableStreamAsyncIterable(stream) {\n  if (stream[Symbol.asyncIterator]) return stream;\n  const reader = stream.getReader();\n  return {\n    async next() {\n      try {\n        const result = await reader.read();\n        if (result?.done) reader.releaseLock(); // release lock when stream becomes closed\n        return result;\n      } catch (e) {\n        reader.releaseLock(); // release lock when stream becomes errored\n        throw e;\n      }\n    },\n    async return() {\n      const cancelPromise = reader.cancel();\n      reader.releaseLock();\n      await cancelPromise;\n      return {\n        done: true,\n        value: undefined\n      };\n    },\n    [Symbol.asyncIterator]() {\n      return this;\n    }\n  };\n}","map":{"version":3,"names":["ReadableStream","GroqError","APIError","Stream","constructor","iterator","controller","fromSSEResponse","response","consumed","decoder","SSEDecoder","iterMessages","body","abort","lineDecoder","LineDecoder","iter","readableStreamAsyncIterable","chunk","line","decode","sse","flush","Error","done","data","startsWith","event","JSON","parse","e","console","error","raw","status_code","message","undefined","name","fromReadableStream","readableStream","iterLines","Symbol","asyncIterator","tee","left","right","teeIterator","queue","next","length","result","push","shift","toReadableStream","self","encoder","TextEncoder","start","pull","ctrl","value","close","bytes","encode","stringify","enqueue","err","cancel","return","chunks","endsWith","substring","join","fieldname","_","partition","buffer","trailingCR","text","decodeText","slice","trailingNewline","NEWLINE_CHARS","has","lines","split","NEWLINE_REGEXP","pop","Buffer","toString","Uint8Array","from","TextDecoder","ArrayBuffer","textDecoder","Set","str","delimiter","index","indexOf","stream","reader","getReader","read","releaseLock","cancelPromise"],"sources":["D:\\consultancy_project\\consultancy_project\\client\\node_modules\\groq-sdk\\src\\lib\\streaming.ts"],"sourcesContent":["import { ReadableStream, type Response } from '../_shims/index';\r\nimport { GroqError } from '../error';\r\n\r\nimport { APIError } from '../error';\r\n\r\ntype Bytes = string | ArrayBuffer | Uint8Array | Buffer | null | undefined;\r\n\r\nexport type ServerSentEvent = {\r\n  event: string | null;\r\n  data: string;\r\n  raw: string[];\r\n};\r\n\r\nexport class Stream<Item> implements AsyncIterable<Item> {\r\n  controller: AbortController;\r\n\r\n  constructor(\r\n    private iterator: () => AsyncIterator<Item>,\r\n    controller: AbortController,\r\n  ) {\r\n    this.controller = controller;\r\n  }\r\n\r\n  static fromSSEResponse<Item>(response: Response, controller: AbortController) {\r\n    let consumed = false;\r\n    const decoder = new SSEDecoder();\r\n\r\n    async function* iterMessages(): AsyncGenerator<ServerSentEvent, void, unknown> {\r\n      if (!response.body) {\r\n        controller.abort();\r\n        throw new GroqError(`Attempted to iterate over a response with no body`);\r\n      }\r\n\r\n      const lineDecoder = new LineDecoder();\r\n\r\n      const iter = readableStreamAsyncIterable<Bytes>(response.body);\r\n      for await (const chunk of iter) {\r\n        for (const line of lineDecoder.decode(chunk)) {\r\n          const sse = decoder.decode(line);\r\n          if (sse) yield sse;\r\n        }\r\n      }\r\n\r\n      for (const line of lineDecoder.flush()) {\r\n        const sse = decoder.decode(line);\r\n        if (sse) yield sse;\r\n      }\r\n    }\r\n\r\n    async function* iterator(): AsyncIterator<Item, any, undefined> {\r\n      if (consumed) {\r\n        throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\r\n      }\r\n      consumed = true;\r\n      let done = false;\r\n      try {\r\n        for await (const sse of iterMessages()) {\r\n          if (done) continue;\r\n\r\n          if (sse.data.startsWith('[DONE]')) {\r\n            done = true;\r\n            continue;\r\n          }\r\n\r\n          if (sse.event === null || sse.event === 'error') {\r\n            let data;\r\n\r\n            try {\r\n              data = JSON.parse(sse.data);\r\n            } catch (e) {\r\n              console.error(`Could not parse message into JSON:`, sse.data);\r\n              console.error(`From chunk:`, sse.raw);\r\n              throw e;\r\n            }\r\n\r\n            if (data && data.error) {\r\n              throw new APIError(data.error.status_code, data.error, data.error.message, undefined);\r\n            }\r\n\r\n            yield data;\r\n          }\r\n        }\r\n        done = true;\r\n      } catch (e) {\r\n        // If the user calls `stream.controller.abort()`, we should exit without throwing.\r\n        if (e instanceof Error && e.name === 'AbortError') return;\r\n        throw e;\r\n      } finally {\r\n        // If the user `break`s, abort the ongoing request.\r\n        if (!done) controller.abort();\r\n      }\r\n    }\r\n\r\n    return new Stream(iterator, controller);\r\n  }\r\n\r\n  /**\r\n   * Generates a Stream from a newline-separated ReadableStream\r\n   * where each item is a JSON value.\r\n   */\r\n  static fromReadableStream<Item>(readableStream: ReadableStream, controller: AbortController) {\r\n    let consumed = false;\r\n\r\n    async function* iterLines(): AsyncGenerator<string, void, unknown> {\r\n      const lineDecoder = new LineDecoder();\r\n\r\n      const iter = readableStreamAsyncIterable<Bytes>(readableStream);\r\n      for await (const chunk of iter) {\r\n        for (const line of lineDecoder.decode(chunk)) {\r\n          yield line;\r\n        }\r\n      }\r\n\r\n      for (const line of lineDecoder.flush()) {\r\n        yield line;\r\n      }\r\n    }\r\n\r\n    async function* iterator(): AsyncIterator<Item, any, undefined> {\r\n      if (consumed) {\r\n        throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\r\n      }\r\n      consumed = true;\r\n      let done = false;\r\n      try {\r\n        for await (const line of iterLines()) {\r\n          if (done) continue;\r\n          if (line) yield JSON.parse(line);\r\n        }\r\n        done = true;\r\n      } catch (e) {\r\n        // If the user calls `stream.controller.abort()`, we should exit without throwing.\r\n        if (e instanceof Error && e.name === 'AbortError') return;\r\n        throw e;\r\n      } finally {\r\n        // If the user `break`s, abort the ongoing request.\r\n        if (!done) controller.abort();\r\n      }\r\n    }\r\n\r\n    return new Stream(iterator, controller);\r\n  }\r\n\r\n  [Symbol.asyncIterator](): AsyncIterator<Item> {\r\n    return this.iterator();\r\n  }\r\n\r\n  /**\r\n   * Splits the stream into two streams which can be\r\n   * independently read from at different speeds.\r\n   */\r\n  tee(): [Stream<Item>, Stream<Item>] {\r\n    const left: Array<Promise<IteratorResult<Item>>> = [];\r\n    const right: Array<Promise<IteratorResult<Item>>> = [];\r\n    const iterator = this.iterator();\r\n\r\n    const teeIterator = (queue: Array<Promise<IteratorResult<Item>>>): AsyncIterator<Item> => {\r\n      return {\r\n        next: () => {\r\n          if (queue.length === 0) {\r\n            const result = iterator.next();\r\n            left.push(result);\r\n            right.push(result);\r\n          }\r\n          return queue.shift()!;\r\n        },\r\n      };\r\n    };\r\n\r\n    return [\r\n      new Stream(() => teeIterator(left), this.controller),\r\n      new Stream(() => teeIterator(right), this.controller),\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Converts this stream to a newline-separated ReadableStream of\r\n   * JSON stringified values in the stream\r\n   * which can be turned back into a Stream with `Stream.fromReadableStream()`.\r\n   */\r\n  toReadableStream(): ReadableStream {\r\n    const self = this;\r\n    let iter: AsyncIterator<Item>;\r\n    const encoder = new TextEncoder();\r\n\r\n    return new ReadableStream({\r\n      async start() {\r\n        iter = self[Symbol.asyncIterator]();\r\n      },\r\n      async pull(ctrl) {\r\n        try {\r\n          const { value, done } = await iter.next();\r\n          if (done) return ctrl.close();\r\n\r\n          const bytes = encoder.encode(JSON.stringify(value) + '\\n');\r\n\r\n          ctrl.enqueue(bytes);\r\n        } catch (err) {\r\n          ctrl.error(err);\r\n        }\r\n      },\r\n      async cancel() {\r\n        await iter.return?.();\r\n      },\r\n    });\r\n  }\r\n}\r\n\r\nclass SSEDecoder {\r\n  private data: string[];\r\n  private event: string | null;\r\n  private chunks: string[];\r\n\r\n  constructor() {\r\n    this.event = null;\r\n    this.data = [];\r\n    this.chunks = [];\r\n  }\r\n\r\n  decode(line: string) {\r\n    if (line.endsWith('\\r')) {\r\n      line = line.substring(0, line.length - 1);\r\n    }\r\n\r\n    if (!line) {\r\n      // empty line and we didn't previously encounter any messages\r\n      if (!this.event && !this.data.length) return null;\r\n\r\n      const sse: ServerSentEvent = {\r\n        event: this.event,\r\n        data: this.data.join('\\n'),\r\n        raw: this.chunks,\r\n      };\r\n\r\n      this.event = null;\r\n      this.data = [];\r\n      this.chunks = [];\r\n\r\n      return sse;\r\n    }\r\n\r\n    this.chunks.push(line);\r\n\r\n    if (line.startsWith(':')) {\r\n      return null;\r\n    }\r\n\r\n    let [fieldname, _, value] = partition(line, ':');\r\n\r\n    if (value.startsWith(' ')) {\r\n      value = value.substring(1);\r\n    }\r\n\r\n    if (fieldname === 'event') {\r\n      this.event = value;\r\n    } else if (fieldname === 'data') {\r\n      this.data.push(value);\r\n    }\r\n\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * A re-implementation of httpx's `LineDecoder` in Python that handles incrementally\r\n * reading lines from text.\r\n *\r\n * https://github.com/encode/httpx/blob/920333ea98118e9cf617f246905d7b202510941c/httpx/_decoders.py#L258\r\n */\r\nclass LineDecoder {\r\n  // prettier-ignore\r\n  static NEWLINE_CHARS = new Set(['\\n', '\\r', '\\x0b', '\\x0c', '\\x1c', '\\x1d', '\\x1e', '\\x85', '\\u2028', '\\u2029']);\r\n  static NEWLINE_REGEXP = /\\r\\n|[\\n\\r\\x0b\\x0c\\x1c\\x1d\\x1e\\x85\\u2028\\u2029]/g;\r\n\r\n  buffer: string[];\r\n  trailingCR: boolean;\r\n  textDecoder: any; // TextDecoder found in browsers; not typed to avoid pulling in either \"dom\" or \"node\" types.\r\n\r\n  constructor() {\r\n    this.buffer = [];\r\n    this.trailingCR = false;\r\n  }\r\n\r\n  decode(chunk: Bytes): string[] {\r\n    let text = this.decodeText(chunk);\r\n\r\n    if (this.trailingCR) {\r\n      text = '\\r' + text;\r\n      this.trailingCR = false;\r\n    }\r\n    if (text.endsWith('\\r')) {\r\n      this.trailingCR = true;\r\n      text = text.slice(0, -1);\r\n    }\r\n\r\n    if (!text) {\r\n      return [];\r\n    }\r\n\r\n    const trailingNewline = LineDecoder.NEWLINE_CHARS.has(text[text.length - 1] || '');\r\n    let lines = text.split(LineDecoder.NEWLINE_REGEXP);\r\n\r\n    if (lines.length === 1 && !trailingNewline) {\r\n      this.buffer.push(lines[0]!);\r\n      return [];\r\n    }\r\n\r\n    if (this.buffer.length > 0) {\r\n      lines = [this.buffer.join('') + lines[0], ...lines.slice(1)];\r\n      this.buffer = [];\r\n    }\r\n\r\n    if (!trailingNewline) {\r\n      this.buffer = [lines.pop() || ''];\r\n    }\r\n\r\n    return lines;\r\n  }\r\n\r\n  decodeText(bytes: Bytes): string {\r\n    if (bytes == null) return '';\r\n    if (typeof bytes === 'string') return bytes;\r\n\r\n    // Node:\r\n    if (typeof Buffer !== 'undefined') {\r\n      if (bytes instanceof Buffer) {\r\n        return bytes.toString();\r\n      }\r\n      if (bytes instanceof Uint8Array) {\r\n        return Buffer.from(bytes).toString();\r\n      }\r\n\r\n      throw new GroqError(\r\n        `Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global \"Buffer\" defined, which this library assumes to be Node. Please report this error.`,\r\n      );\r\n    }\r\n\r\n    // Browser\r\n    if (typeof TextDecoder !== 'undefined') {\r\n      if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {\r\n        this.textDecoder ??= new TextDecoder('utf8');\r\n        return this.textDecoder.decode(bytes);\r\n      }\r\n\r\n      throw new GroqError(\r\n        `Unexpected: received non-Uint8Array/ArrayBuffer (${\r\n          (bytes as any).constructor.name\r\n        }) in a web platform. Please report this error.`,\r\n      );\r\n    }\r\n\r\n    throw new GroqError(\r\n      `Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`,\r\n    );\r\n  }\r\n\r\n  flush(): string[] {\r\n    if (!this.buffer.length && !this.trailingCR) {\r\n      return [];\r\n    }\r\n\r\n    const lines = [this.buffer.join('')];\r\n    this.buffer = [];\r\n    this.trailingCR = false;\r\n    return lines;\r\n  }\r\n}\r\n\r\nfunction partition(str: string, delimiter: string): [string, string, string] {\r\n  const index = str.indexOf(delimiter);\r\n  if (index !== -1) {\r\n    return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];\r\n  }\r\n\r\n  return [str, '', ''];\r\n}\r\n\r\n/**\r\n * Most browsers don't yet have async iterable support for ReadableStream,\r\n * and Node has a very different way of reading bytes from its \"ReadableStream\".\r\n *\r\n * This polyfill was pulled from https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\r\n */\r\nexport function readableStreamAsyncIterable<T>(stream: any): AsyncIterableIterator<T> {\r\n  if (stream[Symbol.asyncIterator]) return stream;\r\n\r\n  const reader = stream.getReader();\r\n  return {\r\n    async next() {\r\n      try {\r\n        const result = await reader.read();\r\n        if (result?.done) reader.releaseLock(); // release lock when stream becomes closed\r\n        return result;\r\n      } catch (e) {\r\n        reader.releaseLock(); // release lock when stream becomes errored\r\n        throw e;\r\n      }\r\n    },\r\n    async return() {\r\n      const cancelPromise = reader.cancel();\r\n      reader.releaseLock();\r\n      await cancelPromise;\r\n      return { done: true, value: undefined };\r\n    },\r\n    [Symbol.asyncIterator]() {\r\n      return this;\r\n    },\r\n  };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}